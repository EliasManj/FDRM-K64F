Sources\OperativeSystem.o:     file format elf32-littlearmSources\OperativeSystem.oarchitecture: arm, flags 0x00000011:HAS_RELOC, HAS_SYMSstart address 0x00000000private flags = 5000000: [Version5 EABI]Sections:Idx Name          Size      VMA       LMA       File off  Algn  0 .text         00000000  00000000  00000000  00000034  2**1                  CONTENTS, ALLOC, LOAD, READONLY, CODE  1 .data         00000000  00000000  00000000  00000034  2**0                  CONTENTS, ALLOC, LOAD, DATA  2 .bss          00000000  00000000  00000000  00000034  2**0                  ALLOC  3 .data.readyQueue 00000234  00000000  00000000  00000034  2**2                  CONTENTS, ALLOC, LOAD, DATA  4 .text.ActivateTask 000000c4  00000000  00000000  00000268  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  5 .text.AddTaskFromAlarm 00000068  00000000  00000000  0000032c  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  6 .text.ActivateTaskIRQ 00000084  00000000  00000000  00000394  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  7 .text.RunNextTask 0000010c  00000000  00000000  00000418  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  8 .text.ChainTask 00000070  00000000  00000000  00000524  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE  9 .text.TerminateTask 0000004c  00000000  00000000  00000594  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 10 .text.CheckNextTask 0000006c  00000000  00000000  000005e0  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 11 .text.RunTask 00000098  00000000  00000000  0000064c  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 12 .text.OS_init 00000060  00000000  00000000  000006e4  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 13 .text.OS_loop 00000034  00000000  00000000  00000744  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 14 .text.checkAutoStartSetReady 000000a8  00000000  00000000  00000778  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 15 .text.Interrupt_Disable 00000044  00000000  00000000  00000820  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 16 .text.Interrupt_Enable 00000070  00000000  00000000  00000864  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 17 .text.get_task_by_id 00000040  00000000  00000000  000008d4  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 18 .text.OS_save_context 00000044  00000000  00000000  00000914  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 19 .text.getRunningTaskID 00000018  00000000  00000000  00000958  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 20 .text.LPTimer_Init 00000090  00000000  00000000  00000970  2**2                  CONTENTS, ALLOC, LOAD, READONLY, CODE 21 .text.RunNextTaskIRQ 000000f4  00000000  00000000  00000a00  2**2                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 22 .debug_info   00000ac6  00000000  00000000  00000af4  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 23 .debug_abbrev 000001d2  00000000  00000000  000015ba  2**0                  CONTENTS, READONLY, DEBUGGING 24 .debug_loc    000003a4  00000000  00000000  0000178c  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 25 .debug_aranges 000000a8  00000000  00000000  00001b30  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 26 .debug_macinfo 000620f9  00000000  00000000  00001bd8  2**0                  CONTENTS, READONLY, DEBUGGING 27 .debug_line   000003be  00000000  00000000  00063cd1  2**0                  CONTENTS, RELOC, READONLY, DEBUGGING 28 .debug_str    000005df  00000000  00000000  0006408f  2**0                  CONTENTS, READONLY, DEBUGGING 29 .comment      0000007a  00000000  00000000  0006466e  2**0                  CONTENTS, READONLY 30 .ARM.attributes 0000003b  00000000  00000000  000646e8  2**0                  CONTENTS, READONLY 31 .debug_frame  00000248  00000000  00000000  00064724  2**2                  CONTENTS, RELOC, READONLY, DEBUGGINGSYMBOL TABLE:00000000 l    df *ABS*	00000000 OperativeSystem.c00000000 l    d  .text	00000000 .text00000000 l    d  .data	00000000 .data00000000 l    d  .bss	00000000 .bss00000000 l    d  .data.readyQueue	00000000 .data.readyQueue00000000 l    d  .text.ActivateTask	00000000 .text.ActivateTask00000000 l    d  .text.AddTaskFromAlarm	00000000 .text.AddTaskFromAlarm00000000 l    d  .text.ActivateTaskIRQ	00000000 .text.ActivateTaskIRQ00000000 l    d  .text.RunNextTask	00000000 .text.RunNextTask00000000 l    d  .text.ChainTask	00000000 .text.ChainTask00000000 l    d  .text.TerminateTask	00000000 .text.TerminateTask00000000 l    d  .text.CheckNextTask	00000000 .text.CheckNextTask00000000 l    d  .text.RunTask	00000000 .text.RunTask00000000 l    d  .text.OS_init	00000000 .text.OS_init00000000 l    d  .text.OS_loop	00000000 .text.OS_loop00000000 l    d  .text.checkAutoStartSetReady	00000000 .text.checkAutoStartSetReady00000000 l    d  .text.Interrupt_Disable	00000000 .text.Interrupt_Disable00000000 l    d  .text.Interrupt_Enable	00000000 .text.Interrupt_Enable00000000 l    d  .text.get_task_by_id	00000000 .text.get_task_by_id00000000 l    d  .text.OS_save_context	00000000 .text.OS_save_context00000000 l    d  .text.getRunningTaskID	00000000 .text.getRunningTaskID00000000 l    d  .text.LPTimer_Init	00000000 .text.LPTimer_Init00000000 l    d  .text.RunNextTaskIRQ	00000000 .text.RunNextTaskIRQ00000000 l    d  .debug_info	00000000 .debug_info00000000 l    d  .debug_abbrev	00000000 .debug_abbrev00000000 l    d  .debug_loc	00000000 .debug_loc00000000 l    d  .debug_aranges	00000000 .debug_aranges00000000 l    d  .debug_macinfo	00000000 .debug_macinfo00000000 l    d  .debug_line	00000000 .debug_line00000000 l    d  .debug_str	00000000 .debug_str00000000 l    d  .debug_frame	00000000 .debug_frame00000000 l    d  .comment	00000000 .comment00000000 l    d  .ARM.attributes	00000000 .ARM.attributes00000004       O *COM*	00000004 context_pointer00000004       O *COM*	00000004 alarm_task_context_pointer00000004       O *COM*	00000004 os_loop_sp00000004       O *COM*	00000004 os_loop_pc00000004       O *COM*	00000004 task_incomplete_rd00000004       O *COM*	00000004 context_lr00000004       O *COM*	00000004 context_sp00000004       O *COM*	00000004 alarm_task_context_sp00000004       O *COM*	00000004 sp00000004       O *COM*	00000004 alarm_task_context_sp_addr00000004       O *COM*	00000004 interrupted_task_sp_pointer00000004       O *COM*	00000004 interrupted_task_sp_addr00000118       O *COM*	00000004 task_arr0000001c       O *COM*	00000004 task_a0000001c       O *COM*	00000004 task_b0000001c       O *COM*	00000004 task_c0000001c       O *COM*	00000004 task_d0000001c       O *COM*	00000004 task_e0000000c       O *COM*	00000004 alarm_list00000006       O *COM*	00000004 alarm_a00000006       O *COM*	00000004 alarm_b00000006       O *COM*	00000004 alarm_c00000006       O *COM*	00000004 alarm_d00000006       O *COM*	00000004 alarm_e0000001c       O *COM*	00000004 task0000001c       O *COM*	00000004 runningTask0000001c       O *COM*	00000004 nextTask00000001       O *COM*	00000001 interrupts_enabled00000000 g     O .data.readyQueue	00000234 readyQueue00000004       O *COM*	00000004 ready_queue00000000 g     F .text.ActivateTask	000000c2 ActivateTask00000000 g     F .text.Interrupt_Disable	00000042 Interrupt_Disable00000000 g     F .text.get_task_by_id	00000040 get_task_by_id00000000         *UND*	00000000 Queue_Add00000000 g     F .text.CheckNextTask	0000006a CheckNextTask00000000 g     F .text.RunNextTask	0000010c RunNextTask00000000 g     F .text.AddTaskFromAlarm	00000066 AddTaskFromAlarm00000000 g     F .text.ActivateTaskIRQ	00000084 ActivateTaskIRQ00000000 g     F .text.RunNextTaskIRQ	000000f2 RunNextTaskIRQ00000000 g     F .text.RunTask	00000096 RunTask00000000 g     F .text.ChainTask	0000006e ChainTask00000000 g     F .text.TerminateTask	0000004c TerminateTask00000000         *UND*	00000000 get_empty_TASK00000000         *UND*	00000000 TaskList_Empty00000000         *UND*	00000000 Sort_TaskList00000000         *UND*	00000000 Queue_Next00000000 g     F .text.Interrupt_Enable	0000006e Interrupt_Enable00000000         *UND*	00000000 restore_context00000000         *UND*	00000000 set_pc_sp00000000 g     F .text.OS_init	00000060 OS_init00000000 g     F .text.checkAutoStartSetReady	000000a6 checkAutoStartSetReady00000000 g     F .text.LPTimer_Init	00000090 LPTimer_Init00000000 g     F .text.OS_loop	00000032 OS_loop00000000 g     F .text.OS_save_context	00000044 OS_save_context00000000 g     F .text.getRunningTaskID	00000016 getRunningTaskIDDisassembly of section .text.ActivateTask:00000000 <ActivateTask>:uint8_t interrupts_enabled;QueueType readyQueue = { 0, 0, STATIC_ALLOC, { } };QueueType *ready_queue;void ActivateTask(int task_id) {   0:	b5f0      	push	{r4, r5, r6, r7, lr}   2:	b08f      	sub	sp, #60	; 0x3c   4:	af04      	add	r7, sp, #16   6:	6278      	str	r0, [r7, #36]	; 0x24extern void test2();__attribute__( ( always_inline )) __STATIC_INLINE uint32_t __get_LR(void) {	register uint32_t result;	__ASM volatile ("MOV %0, LR\n" : "=r" (result) );   8:	4674      	mov	r4, lr	return (result);   a:	4623      	mov	r3, r4QueueType readyQueue = { 0, 0, STATIC_ALLOC, { } };QueueType *ready_queue;void ActivateTask(int task_id) {	task_incomplete_rd = __get_LR();   c:	461a      	mov	r2, r3   e:	f240 0300 	movw	r3, #0			e: R_ARM_THM_MOVW_ABS_NC	task_incomplete_rd  12:	f2c0 0300 	movt	r3, #0			12: R_ARM_THM_MOVT_ABS	task_incomplete_rd  16:	601a      	str	r2, [r3, #0]	Interrupt_Disable();  18:	f7ff fffe 	bl	0 <ActivateTask>			18: R_ARM_THM_CALL	Interrupt_Disable	sp = SP_c;  1c:	466a      	mov	r2, sp  1e:	f240 0300 	movw	r3, #0			1e: R_ARM_THM_MOVW_ABS_NC	sp  22:	f2c0 0300 	movt	r3, #0			22: R_ARM_THM_MOVT_ABS	sp  26:	601a      	str	r2, [r3, #0]	task = get_task_by_id(task_id);  28:	f240 0400 	movw	r4, #0			28: R_ARM_THM_MOVW_ABS_NC	task  2c:	f2c0 0400 	movt	r4, #0			2c: R_ARM_THM_MOVT_ABS	task  30:	463b      	mov	r3, r7  32:	4618      	mov	r0, r3  34:	6a79      	ldr	r1, [r7, #36]	; 0x24  36:	f7ff fffe 	bl	0 <ActivateTask>			36: R_ARM_THM_CALL	get_task_by_id  3a:	463d      	mov	r5, r7  3c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}  3e:	c40f      	stmia	r4!, {r0, r1, r2, r3}  40:	e895 0007 	ldmia.w	r5, {r0, r1, r2}  44:	e884 0007 	stmia.w	r4, {r0, r1, r2}	task.state = READY;  48:	f240 0300 	movw	r3, #0			48: R_ARM_THM_MOVW_ABS_NC	task  4c:	f2c0 0300 	movt	r3, #0			4c: R_ARM_THM_MOVT_ABS	task  50:	f04f 0201 	mov.w	r2, #1  54:	761a      	strb	r2, [r3, #24]	if (runningTask.id == task.id) {  56:	f240 0300 	movw	r3, #0			56: R_ARM_THM_MOVW_ABS_NC	runningTask  5a:	f2c0 0300 	movt	r3, #0			5a: R_ARM_THM_MOVT_ABS	runningTask  5e:	691a      	ldr	r2, [r3, #16]  60:	f240 0300 	movw	r3, #0			60: R_ARM_THM_MOVW_ABS_NC	task  64:	f2c0 0300 	movt	r3, #0			64: R_ARM_THM_MOVT_ABS	task  68:	691b      	ldr	r3, [r3, #16]  6a:	429a      	cmp	r2, r3  6c:	d10d      	bne.n	8a <ActivateTask+0x8a>		task.multiplicity = runningTask.multiplicity + 1;  6e:	f240 0300 	movw	r3, #0			6e: R_ARM_THM_MOVW_ABS_NC	runningTask  72:	f2c0 0300 	movt	r3, #0			72: R_ARM_THM_MOVT_ABS	runningTask  76:	7e9b      	ldrb	r3, [r3, #26]  78:	b2db      	uxtb	r3, r3  7a:	f103 0301 	add.w	r3, r3, #1  7e:	b2da      	uxtb	r2, r3  80:	f240 0300 	movw	r3, #0			80: R_ARM_THM_MOVW_ABS_NC	task  84:	f2c0 0300 	movt	r3, #0			84: R_ARM_THM_MOVT_ABS	task  88:	769a      	strb	r2, [r3, #26]	}	//set_lr_sp(a, sp);	//test();	Queue_Add(ready_queue, task);  8a:	f240 0300 	movw	r3, #0			8a: R_ARM_THM_MOVW_ABS_NC	ready_queue  8e:	f2c0 0300 	movt	r3, #0			8e: R_ARM_THM_MOVT_ABS	ready_queue  92:	681e      	ldr	r6, [r3, #0]  94:	f240 0400 	movw	r4, #0			94: R_ARM_THM_MOVW_ABS_NC	task  98:	f2c0 0400 	movt	r4, #0			98: R_ARM_THM_MOVT_ABS	task  9c:	466d      	mov	r5, sp  9e:	f104 030c 	add.w	r3, r4, #12  a2:	cb0f      	ldmia	r3, {r0, r1, r2, r3}  a4:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}  a8:	e894 000e 	ldmia.w	r4, {r1, r2, r3}  ac:	4630      	mov	r0, r6  ae:	f7ff fffe 	bl	0 <Queue_Add>			ae: R_ARM_THM_CALL	Queue_Add	CheckNextTask();  b2:	f7ff fffe 	bl	0 <ActivateTask>			b2: R_ARM_THM_CALL	CheckNextTask	RunNextTask();  b6:	f7ff fffe 	bl	0 <ActivateTask>			b6: R_ARM_THM_CALL	RunNextTask}  ba:	f107 072c 	add.w	r7, r7, #44	; 0x2c  be:	46bd      	mov	sp, r7  c0:	bdf0      	pop	{r4, r5, r6, r7, pc}  c2:	bf00      	nopDisassembly of section .text.AddTaskFromAlarm:00000000 <AddTaskFromAlarm>:void AddTaskFromAlarm(int task_id) {   0:	b5f0      	push	{r4, r5, r6, r7, lr}   2:	b08f      	sub	sp, #60	; 0x3c   4:	af04      	add	r7, sp, #16   6:	6278      	str	r0, [r7, #36]	; 0x24	task = get_task_by_id(task_id);   8:	f240 0400 	movw	r4, #0			8: R_ARM_THM_MOVW_ABS_NC	task   c:	f2c0 0400 	movt	r4, #0			c: R_ARM_THM_MOVT_ABS	task  10:	463b      	mov	r3, r7  12:	4618      	mov	r0, r3  14:	6a79      	ldr	r1, [r7, #36]	; 0x24  16:	f7ff fffe 	bl	0 <AddTaskFromAlarm>			16: R_ARM_THM_CALL	get_task_by_id  1a:	463d      	mov	r5, r7  1c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}  1e:	c40f      	stmia	r4!, {r0, r1, r2, r3}  20:	e895 0007 	ldmia.w	r5, {r0, r1, r2}  24:	e884 0007 	stmia.w	r4, {r0, r1, r2}	task.state = READY;  28:	f240 0300 	movw	r3, #0			28: R_ARM_THM_MOVW_ABS_NC	task  2c:	f2c0 0300 	movt	r3, #0			2c: R_ARM_THM_MOVT_ABS	task  30:	f04f 0201 	mov.w	r2, #1  34:	761a      	strb	r2, [r3, #24]	Queue_Add(ready_queue, task);  36:	f240 0300 	movw	r3, #0			36: R_ARM_THM_MOVW_ABS_NC	ready_queue  3a:	f2c0 0300 	movt	r3, #0			3a: R_ARM_THM_MOVT_ABS	ready_queue  3e:	681e      	ldr	r6, [r3, #0]  40:	f240 0400 	movw	r4, #0			40: R_ARM_THM_MOVW_ABS_NC	task  44:	f2c0 0400 	movt	r4, #0			44: R_ARM_THM_MOVT_ABS	task  48:	466d      	mov	r5, sp  4a:	f104 030c 	add.w	r3, r4, #12  4e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}  50:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}  54:	e894 000e 	ldmia.w	r4, {r1, r2, r3}  58:	4630      	mov	r0, r6  5a:	f7ff fffe 	bl	0 <Queue_Add>			5a: R_ARM_THM_CALL	Queue_Add}  5e:	f107 072c 	add.w	r7, r7, #44	; 0x2c  62:	46bd      	mov	sp, r7  64:	bdf0      	pop	{r4, r5, r6, r7, pc}  66:	bf00      	nopDisassembly of section .text.ActivateTaskIRQ:00000000 <ActivateTaskIRQ>:void ActivateTaskIRQ(int task_id) {   0:	b5f0      	push	{r4, r5, r6, r7, lr}   2:	b08f      	sub	sp, #60	; 0x3c   4:	af04      	add	r7, sp, #16   6:	6278      	str	r0, [r7, #36]	; 0x24extern void test2();__attribute__( ( always_inline )) __STATIC_INLINE uint32_t __get_LR(void) {	register uint32_t result;	__ASM volatile ("MOV %0, LR\n" : "=r" (result) );   8:	4674      	mov	r4, lr	return (result);   a:	4623      	mov	r3, r4	task.state = READY;	Queue_Add(ready_queue, task);}void ActivateTaskIRQ(int task_id) {	context_lr = __get_LR();   c:	461a      	mov	r2, r3   e:	f240 0300 	movw	r3, #0			e: R_ARM_THM_MOVW_ABS_NC	context_lr  12:	f2c0 0300 	movt	r3, #0			12: R_ARM_THM_MOVT_ABS	context_lr  16:	601a      	str	r2, [r3, #0]	task = get_task_by_id(task_id);  18:	f240 0400 	movw	r4, #0			18: R_ARM_THM_MOVW_ABS_NC	task  1c:	f2c0 0400 	movt	r4, #0			1c: R_ARM_THM_MOVT_ABS	task  20:	463b      	mov	r3, r7  22:	4618      	mov	r0, r3  24:	6a79      	ldr	r1, [r7, #36]	; 0x24  26:	f7ff fffe 	bl	0 <ActivateTaskIRQ>			26: R_ARM_THM_CALL	get_task_by_id  2a:	463d      	mov	r5, r7  2c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}  2e:	c40f      	stmia	r4!, {r0, r1, r2, r3}  30:	e895 0007 	ldmia.w	r5, {r0, r1, r2}  34:	e884 0007 	stmia.w	r4, {r0, r1, r2}	task.state = READY;  38:	f240 0300 	movw	r3, #0			38: R_ARM_THM_MOVW_ABS_NC	task  3c:	f2c0 0300 	movt	r3, #0			3c: R_ARM_THM_MOVT_ABS	task  40:	f04f 0201 	mov.w	r2, #1  44:	761a      	strb	r2, [r3, #24]	Queue_Add(ready_queue, task);  46:	f240 0300 	movw	r3, #0			46: R_ARM_THM_MOVW_ABS_NC	ready_queue  4a:	f2c0 0300 	movt	r3, #0			4a: R_ARM_THM_MOVT_ABS	ready_queue  4e:	681e      	ldr	r6, [r3, #0]  50:	f240 0400 	movw	r4, #0			50: R_ARM_THM_MOVW_ABS_NC	task  54:	f2c0 0400 	movt	r4, #0			54: R_ARM_THM_MOVT_ABS	task  58:	466d      	mov	r5, sp  5a:	f104 030c 	add.w	r3, r4, #12  5e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}  60:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}  64:	e894 000e 	ldmia.w	r4, {r1, r2, r3}  68:	4630      	mov	r0, r6  6a:	f7ff fffe 	bl	0 <Queue_Add>			6a: R_ARM_THM_CALL	Queue_Add	if (CheckNextTask()) {  6e:	f7ff fffe 	bl	0 <ActivateTaskIRQ>			6e: R_ARM_THM_CALL	CheckNextTask  72:	4603      	mov	r3, r0  74:	2b00      	cmp	r3, #0  76:	d001      	beq.n	7c <ActivateTaskIRQ+0x7c>		RunNextTaskIRQ();  78:	f7ff fffe 	bl	0 <ActivateTaskIRQ>			78: R_ARM_THM_CALL	RunNextTaskIRQ	}}  7c:	f107 072c 	add.w	r7, r7, #44	; 0x2c  80:	46bd      	mov	sp, r7  82:	bdf0      	pop	{r4, r5, r6, r7, pc}Disassembly of section .text.RunNextTask:00000000 <RunNextTask>:void RunNextTask() {   0:	b5f0      	push	{r4, r5, r6, r7, lr}   2:	b085      	sub	sp, #20   4:	af04      	add	r7, sp, #16	if (runningTask.label == 'X') {   6:	f240 0300 	movw	r3, #0			6: R_ARM_THM_MOVW_ABS_NC	runningTask   a:	f2c0 0300 	movt	r3, #0			a: R_ARM_THM_MOVT_ABS	runningTask   e:	7b1b      	ldrb	r3, [r3, #12]  10:	b2db      	uxtb	r3, r3  12:	2b58      	cmp	r3, #88	; 0x58  14:	d112      	bne.n	3c <RunNextTask+0x3c>		runningTask = nextTask;  16:	f240 0200 	movw	r2, #0			16: R_ARM_THM_MOVW_ABS_NC	runningTask  1a:	f2c0 0200 	movt	r2, #0			1a: R_ARM_THM_MOVT_ABS	runningTask  1e:	f240 0300 	movw	r3, #0			1e: R_ARM_THM_MOVW_ABS_NC	nextTask  22:	f2c0 0300 	movt	r3, #0			22: R_ARM_THM_MOVT_ABS	nextTask  26:	4614      	mov	r4, r2  28:	461d      	mov	r5, r3  2a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}  2c:	c40f      	stmia	r4!, {r0, r1, r2, r3}  2e:	e895 0007 	ldmia.w	r5, {r0, r1, r2}  32:	e884 0007 	stmia.w	r4, {r0, r1, r2}		RunTask();  36:	f7ff fffe 	bl	0 <RunNextTask>			36: R_ARM_THM_CALL	RunTask  3a:	e063      	b.n	e6 <RunNextTask+0xe6>	} else if (nextTask.priority >= runningTask.priority) {  3c:	f240 0300 	movw	r3, #0			3c: R_ARM_THM_MOVW_ABS_NC	nextTask  40:	f2c0 0300 	movt	r3, #0			40: R_ARM_THM_MOVT_ABS	nextTask  44:	781b      	ldrb	r3, [r3, #0]  46:	b2da      	uxtb	r2, r3  48:	f240 0300 	movw	r3, #0			48: R_ARM_THM_MOVW_ABS_NC	runningTask  4c:	f2c0 0300 	movt	r3, #0			4c: R_ARM_THM_MOVT_ABS	runningTask  50:	781b      	ldrb	r3, [r3, #0]  52:	b2db      	uxtb	r3, r3  54:	429a      	cmp	r2, r3  56:	d341      	bcc.n	dc <RunNextTask+0xdc>		runningTask.return_direction = task_incomplete_rd;  58:	f240 0300 	movw	r3, #0			58: R_ARM_THM_MOVW_ABS_NC	task_incomplete_rd  5c:	f2c0 0300 	movt	r3, #0			5c: R_ARM_THM_MOVT_ABS	task_incomplete_rd  60:	681a      	ldr	r2, [r3, #0]  62:	f240 0300 	movw	r3, #0			62: R_ARM_THM_MOVW_ABS_NC	runningTask  66:	f2c0 0300 	movt	r3, #0			66: R_ARM_THM_MOVT_ABS	runningTask  6a:	605a      	str	r2, [r3, #4]		runningTask.return_sp = sp;  6c:	f240 0300 	movw	r3, #0			6c: R_ARM_THM_MOVW_ABS_NC	sp  70:	f2c0 0300 	movt	r3, #0			70: R_ARM_THM_MOVT_ABS	sp  74:	681a      	ldr	r2, [r3, #0]  76:	f240 0300 	movw	r3, #0			76: R_ARM_THM_MOVW_ABS_NC	runningTask  7a:	f2c0 0300 	movt	r3, #0			7a: R_ARM_THM_MOVT_ABS	runningTask  7e:	609a      	str	r2, [r3, #8]		runningTask.state = READY;  80:	f240 0300 	movw	r3, #0			80: R_ARM_THM_MOVW_ABS_NC	runningTask  84:	f2c0 0300 	movt	r3, #0			84: R_ARM_THM_MOVT_ABS	runningTask  88:	f04f 0201 	mov.w	r2, #1  8c:	761a      	strb	r2, [r3, #24]		Queue_Add(ready_queue, runningTask);  8e:	f240 0300 	movw	r3, #0			8e: R_ARM_THM_MOVW_ABS_NC	ready_queue  92:	f2c0 0300 	movt	r3, #0			92: R_ARM_THM_MOVT_ABS	ready_queue  96:	681e      	ldr	r6, [r3, #0]  98:	f240 0400 	movw	r4, #0			98: R_ARM_THM_MOVW_ABS_NC	runningTask  9c:	f2c0 0400 	movt	r4, #0			9c: R_ARM_THM_MOVT_ABS	runningTask  a0:	466d      	mov	r5, sp  a2:	f104 030c 	add.w	r3, r4, #12  a6:	cb0f      	ldmia	r3, {r0, r1, r2, r3}  a8:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}  ac:	e894 000e 	ldmia.w	r4, {r1, r2, r3}  b0:	4630      	mov	r0, r6  b2:	f7ff fffe 	bl	0 <Queue_Add>			b2: R_ARM_THM_CALL	Queue_Add		runningTask = nextTask;  b6:	f240 0200 	movw	r2, #0			b6: R_ARM_THM_MOVW_ABS_NC	runningTask  ba:	f2c0 0200 	movt	r2, #0			ba: R_ARM_THM_MOVT_ABS	runningTask  be:	f240 0300 	movw	r3, #0			be: R_ARM_THM_MOVW_ABS_NC	nextTask  c2:	f2c0 0300 	movt	r3, #0			c2: R_ARM_THM_MOVT_ABS	nextTask  c6:	4614      	mov	r4, r2  c8:	461d      	mov	r5, r3  ca:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}  cc:	c40f      	stmia	r4!, {r0, r1, r2, r3}  ce:	e895 0007 	ldmia.w	r5, {r0, r1, r2}  d2:	e884 0007 	stmia.w	r4, {r0, r1, r2}		RunTask();  d6:	f7ff fffe 	bl	0 <RunNextTask>			d6: R_ARM_THM_CALL	RunTask  da:	e013      	b.n	2e <RunNextTask+0x2e>	} else {		//Case when a task activated another task that has lower priority so the current task continues		Queue_Add(ready_queue, nextTask);  dc:	f240 0300 	movw	r3, #0			dc: R_ARM_THM_MOVW_ABS_NC	ready_queue  e0:	f2c0 0300 	movt	r3, #0			e0: R_ARM_THM_MOVT_ABS	ready_queue  e4:	681e      	ldr	r6, [r3, #0]  e6:	f240 0400 	movw	r4, #0			e6: R_ARM_THM_MOVW_ABS_NC	nextTask  ea:	f2c0 0400 	movt	r4, #0			ea: R_ARM_THM_MOVT_ABS	nextTask  ee:	466d      	mov	r5, sp  f0:	f104 030c 	add.w	r3, r4, #12  f4:	cb0f      	ldmia	r3, {r0, r1, r2, r3}  f6:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}  fa:	e894 000e 	ldmia.w	r4, {r1, r2, r3}  fe:	4630      	mov	r0, r6 100:	f7ff fffe 	bl	0 <Queue_Add>			100: R_ARM_THM_CALL	Queue_Add		//runningTask.return_direction = a;		//set_lr_sp(runningTask.return_direction, sp);	}} 104:	f107 0704 	add.w	r7, r7, #4 108:	46bd      	mov	sp, r7 10a:	bdf0      	pop	{r4, r5, r6, r7, pc}Disassembly of section .text.ChainTask:00000000 <ChainTask>:void ChainTask(int task_id) {   0:	b5f0      	push	{r4, r5, r6, r7, lr}   2:	b08f      	sub	sp, #60	; 0x3c   4:	af04      	add	r7, sp, #16   6:	6278      	str	r0, [r7, #36]	; 0x24	Interrupt_Disable();   8:	f7ff fffe 	bl	0 <ChainTask>			8: R_ARM_THM_CALL	Interrupt_Disable	task = get_task_by_id(task_id);   c:	f240 0400 	movw	r4, #0			c: R_ARM_THM_MOVW_ABS_NC	task  10:	f2c0 0400 	movt	r4, #0			10: R_ARM_THM_MOVT_ABS	task  14:	463b      	mov	r3, r7  16:	4618      	mov	r0, r3  18:	6a79      	ldr	r1, [r7, #36]	; 0x24  1a:	f7ff fffe 	bl	0 <ChainTask>			1a: R_ARM_THM_CALL	get_task_by_id  1e:	463d      	mov	r5, r7  20:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}  22:	c40f      	stmia	r4!, {r0, r1, r2, r3}  24:	e895 0007 	ldmia.w	r5, {r0, r1, r2}  28:	e884 0007 	stmia.w	r4, {r0, r1, r2}	Queue_Add(ready_queue, task);  2c:	f240 0300 	movw	r3, #0			2c: R_ARM_THM_MOVW_ABS_NC	ready_queue  30:	f2c0 0300 	movt	r3, #0			30: R_ARM_THM_MOVT_ABS	ready_queue  34:	681e      	ldr	r6, [r3, #0]  36:	f240 0400 	movw	r4, #0			36: R_ARM_THM_MOVW_ABS_NC	task  3a:	f2c0 0400 	movt	r4, #0			3a: R_ARM_THM_MOVT_ABS	task  3e:	466d      	mov	r5, sp  40:	f104 030c 	add.w	r3, r4, #12  44:	cb0f      	ldmia	r3, {r0, r1, r2, r3}  46:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}  4a:	e894 000e 	ldmia.w	r4, {r1, r2, r3}  4e:	4630      	mov	r0, r6  50:	f7ff fffe 	bl	0 <Queue_Add>			50: R_ARM_THM_CALL	Queue_Add	task.state = READY;  54:	f240 0300 	movw	r3, #0			54: R_ARM_THM_MOVW_ABS_NC	task  58:	f2c0 0300 	movt	r3, #0			58: R_ARM_THM_MOVT_ABS	task  5c:	f04f 0201 	mov.w	r2, #1  60:	761a      	strb	r2, [r3, #24]	TerminateTask();  62:	f7ff fffe 	bl	0 <ChainTask>			62: R_ARM_THM_CALL	TerminateTask}  66:	f107 072c 	add.w	r7, r7, #44	; 0x2c  6a:	46bd      	mov	sp, r7  6c:	bdf0      	pop	{r4, r5, r6, r7, pc}  6e:	bf00      	nopDisassembly of section .text.TerminateTask:00000000 <TerminateTask>:void TerminateTask(void) {   0:	b5b0      	push	{r4, r5, r7, lr}   2:	b088      	sub	sp, #32   4:	af00      	add	r7, sp, #0	Interrupt_Disable();   6:	f7ff fffe 	bl	0 <TerminateTask>			6: R_ARM_THM_CALL	Interrupt_Disable	runningTask.state = IDLE;   a:	f240 0300 	movw	r3, #0			a: R_ARM_THM_MOVW_ABS_NC	runningTask   e:	f2c0 0300 	movt	r3, #0			e: R_ARM_THM_MOVT_ABS	runningTask  12:	f04f 0200 	mov.w	r2, #0  16:	761a      	strb	r2, [r3, #24]	runningTask = get_empty_TASK();  18:	f240 0400 	movw	r4, #0			18: R_ARM_THM_MOVW_ABS_NC	runningTask  1c:	f2c0 0400 	movt	r4, #0			1c: R_ARM_THM_MOVT_ABS	runningTask  20:	463b      	mov	r3, r7  22:	4618      	mov	r0, r3  24:	f7ff fffe 	bl	0 <get_empty_TASK>			24: R_ARM_THM_CALL	get_empty_TASK  28:	463d      	mov	r5, r7  2a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}  2c:	c40f      	stmia	r4!, {r0, r1, r2, r3}  2e:	e895 0007 	ldmia.w	r5, {r0, r1, r2}  32:	e884 0007 	stmia.w	r4, {r0, r1, r2}	if (CheckNextTask()) {  36:	f7ff fffe 	bl	0 <TerminateTask>			36: R_ARM_THM_CALL	CheckNextTask  3a:	4603      	mov	r3, r0  3c:	2b00      	cmp	r3, #0  3e:	d001      	beq.n	44 <TerminateTask+0x44>		RunNextTask();  40:	f7ff fffe 	bl	0 <TerminateTask>			40: R_ARM_THM_CALL	RunNextTask	}}  44:	f107 0720 	add.w	r7, r7, #32  48:	46bd      	mov	sp, r7  4a:	bdb0      	pop	{r4, r5, r7, pc}Disassembly of section .text.CheckNextTask:00000000 <CheckNextTask>:int CheckNextTask(void) {   0:	b5b0      	push	{r4, r5, r7, lr}   2:	b088      	sub	sp, #32   4:	af00      	add	r7, sp, #0	if (TaskList_Empty(ready_queue)) {   6:	f240 0300 	movw	r3, #0			6: R_ARM_THM_MOVW_ABS_NC	ready_queue   a:	f2c0 0300 	movt	r3, #0			a: R_ARM_THM_MOVT_ABS	ready_queue   e:	681b      	ldr	r3, [r3, #0]  10:	4618      	mov	r0, r3  12:	f7ff fffe 	bl	0 <TaskList_Empty>			12: R_ARM_THM_CALL	TaskList_Empty  16:	4603      	mov	r3, r0  18:	2b00      	cmp	r3, #0  1a:	d002      	beq.n	22 <CheckNextTask+0x22>		return 0;  1c:	f04f 0300 	mov.w	r3, #0  20:	e01e      	b.n	44 <CheckNextTask+0x44>	}	Sort_TaskList(ready_queue);  22:	f240 0300 	movw	r3, #0			22: R_ARM_THM_MOVW_ABS_NC	ready_queue  26:	f2c0 0300 	movt	r3, #0			26: R_ARM_THM_MOVT_ABS	ready_queue  2a:	681b      	ldr	r3, [r3, #0]  2c:	4618      	mov	r0, r3  2e:	f7ff fffe 	bl	0 <Sort_TaskList>			2e: R_ARM_THM_CALL	Sort_TaskList	nextTask = Queue_Next(ready_queue);  32:	f240 0300 	movw	r3, #0			32: R_ARM_THM_MOVW_ABS_NC	ready_queue  36:	f2c0 0300 	movt	r3, #0			36: R_ARM_THM_MOVT_ABS	ready_queue  3a:	681b      	ldr	r3, [r3, #0]  3c:	f240 0400 	movw	r4, #0			3c: R_ARM_THM_MOVW_ABS_NC	nextTask  40:	f2c0 0400 	movt	r4, #0			40: R_ARM_THM_MOVT_ABS	nextTask  44:	463a      	mov	r2, r7  46:	4610      	mov	r0, r2  48:	4619      	mov	r1, r3  4a:	f7ff fffe 	bl	0 <Queue_Next>			4a: R_ARM_THM_CALL	Queue_Next  4e:	463d      	mov	r5, r7  50:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}  52:	c40f      	stmia	r4!, {r0, r1, r2, r3}  54:	e895 0007 	ldmia.w	r5, {r0, r1, r2}  58:	e884 0007 	stmia.w	r4, {r0, r1, r2}	return 1;  5c:	f04f 0301 	mov.w	r3, #1}  60:	4618      	mov	r0, r3  62:	f107 0720 	add.w	r7, r7, #32  66:	46bd      	mov	sp, r7  68:	bdb0      	pop	{r4, r5, r7, pc}  6a:	bf00      	nopDisassembly of section .text.RunTask:00000000 <RunTask>:void RunTask(void) {   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0	runningTask.state = RUNNING;   4:	f240 0300 	movw	r3, #0			4: R_ARM_THM_MOVW_ABS_NC	runningTask   8:	f2c0 0300 	movt	r3, #0			8: R_ARM_THM_MOVT_ABS	runningTask   c:	f04f 0202 	mov.w	r2, #2  10:	761a      	strb	r2, [r3, #24]	if (runningTask.context_required == 1) {  12:	f240 0300 	movw	r3, #0			12: R_ARM_THM_MOVW_ABS_NC	runningTask  16:	f2c0 0300 	movt	r3, #0			16: R_ARM_THM_MOVT_ABS	runningTask  1a:	7e5b      	ldrb	r3, [r3, #25]  1c:	b2db      	uxtb	r3, r3  1e:	2b01      	cmp	r3, #1  20:	d118      	bne.n	54 <RunTask+0x54>		runningTask.context_required = 0;  22:	f240 0300 	movw	r3, #0			22: R_ARM_THM_MOVW_ABS_NC	runningTask  26:	f2c0 0300 	movt	r3, #0			26: R_ARM_THM_MOVT_ABS	runningTask  2a:	f04f 0200 	mov.w	r2, #0  2e:	765a      	strb	r2, [r3, #25]		Interrupt_Enable();  30:	f7ff fffe 	bl	0 <RunTask>			30: R_ARM_THM_CALL	Interrupt_Enable		restore_context((uint32_t) context_pointer, context_lr);  34:	f240 0300 	movw	r3, #0			34: R_ARM_THM_MOVW_ABS_NC	context_pointer  38:	f2c0 0300 	movt	r3, #0			38: R_ARM_THM_MOVT_ABS	context_pointer  3c:	681b      	ldr	r3, [r3, #0]  3e:	461a      	mov	r2, r3  40:	f240 0300 	movw	r3, #0			40: R_ARM_THM_MOVW_ABS_NC	context_lr  44:	f2c0 0300 	movt	r3, #0			44: R_ARM_THM_MOVT_ABS	context_lr  48:	681b      	ldr	r3, [r3, #0]  4a:	4610      	mov	r0, r2  4c:	4619      	mov	r1, r3  4e:	f7ff fffe 	bl	0 <restore_context>			4e: R_ARM_THM_CALL	restore_context  52:	e01f      	b.n	5e <RunTask+0x5e>	} else if (runningTask.return_direction != 0) {  54:	f240 0300 	movw	r3, #0			54: R_ARM_THM_MOVW_ABS_NC	runningTask  58:	f2c0 0300 	movt	r3, #0			58: R_ARM_THM_MOVT_ABS	runningTask  5c:	685b      	ldr	r3, [r3, #4]  5e:	2b00      	cmp	r3, #0  60:	d010      	beq.n	84 <RunTask+0x84>		Interrupt_Enable();  62:	f7ff fffe 	bl	0 <RunTask>			62: R_ARM_THM_CALL	Interrupt_Enable		set_pc_sp(runningTask.return_direction, runningTask.return_sp);  66:	f240 0300 	movw	r3, #0			66: R_ARM_THM_MOVW_ABS_NC	runningTask  6a:	f2c0 0300 	movt	r3, #0			6a: R_ARM_THM_MOVT_ABS	runningTask  6e:	685a      	ldr	r2, [r3, #4]  70:	f240 0300 	movw	r3, #0			70: R_ARM_THM_MOVW_ABS_NC	runningTask  74:	f2c0 0300 	movt	r3, #0			74: R_ARM_THM_MOVT_ABS	runningTask  78:	689b      	ldr	r3, [r3, #8]  7a:	4610      	mov	r0, r2  7c:	4619      	mov	r1, r3  7e:	f7ff fffe 	bl	0 <set_pc_sp>			7e: R_ARM_THM_CALL	set_pc_sp  82:	e007      	b.n	12 <RunTask+0x12>	} else {		Interrupt_Enable();  84:	f7ff fffe 	bl	0 <RunTask>			84: R_ARM_THM_CALL	Interrupt_Enable		runningTask.ap_task_init();  88:	f240 0300 	movw	r3, #0			88: R_ARM_THM_MOVW_ABS_NC	runningTask  8c:	f2c0 0300 	movt	r3, #0			8c: R_ARM_THM_MOVT_ABS	runningTask  90:	695b      	ldr	r3, [r3, #20]  92:	4798      	blx	r3	}}  94:	bd80      	pop	{r7, pc}  96:	bf00      	nopDisassembly of section .text.OS_init:00000000 <OS_init>:void OS_init(TASK *tasks, int size) {   0:	b5b0      	push	{r4, r5, r7, lr}   2:	b08a      	sub	sp, #40	; 0x28   4:	af00      	add	r7, sp, #0   6:	6278      	str	r0, [r7, #36]	; 0x24   8:	6239      	str	r1, [r7, #32]	ready_queue = &readyQueue;   a:	f240 0300 	movw	r3, #0			a: R_ARM_THM_MOVW_ABS_NC	ready_queue   e:	f2c0 0300 	movt	r3, #0			e: R_ARM_THM_MOVT_ABS	ready_queue  12:	f240 0200 	movw	r2, #0			12: R_ARM_THM_MOVW_ABS_NC	readyQueue  16:	f2c0 0200 	movt	r2, #0			16: R_ARM_THM_MOVT_ABS	readyQueue  1a:	601a      	str	r2, [r3, #0]	interrupts_enabled = 0;  1c:	f240 0300 	movw	r3, #0			1c: R_ARM_THM_MOVW_ABS_NC	interrupts_enabled  20:	f2c0 0300 	movt	r3, #0			20: R_ARM_THM_MOVT_ABS	interrupts_enabled  24:	f04f 0200 	mov.w	r2, #0  28:	701a      	strb	r2, [r3, #0]	checkAutoStartSetReady(tasks, size);  2a:	6a78      	ldr	r0, [r7, #36]	; 0x24  2c:	6a39      	ldr	r1, [r7, #32]  2e:	f7ff fffe 	bl	0 <OS_init>			2e: R_ARM_THM_CALL	checkAutoStartSetReady	runningTask = get_empty_TASK();  32:	f240 0400 	movw	r4, #0			32: R_ARM_THM_MOVW_ABS_NC	runningTask  36:	f2c0 0400 	movt	r4, #0			36: R_ARM_THM_MOVT_ABS	runningTask  3a:	463b      	mov	r3, r7  3c:	4618      	mov	r0, r3  3e:	f7ff fffe 	bl	0 <get_empty_TASK>			3e: R_ARM_THM_CALL	get_empty_TASK  42:	463d      	mov	r5, r7  44:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}  46:	c40f      	stmia	r4!, {r0, r1, r2, r3}  48:	e895 0007 	ldmia.w	r5, {r0, r1, r2}  4c:	e884 0007 	stmia.w	r4, {r0, r1, r2}	//Alarms_Disable();	LPTimer_Init();  50:	f7ff fffe 	bl	0 <OS_init>			50: R_ARM_THM_CALL	LPTimer_Init	OS_loop();  54:	f7ff fffe 	bl	0 <OS_init>			54: R_ARM_THM_CALL	OS_loop}  58:	f107 0728 	add.w	r7, r7, #40	; 0x28  5c:	46bd      	mov	sp, r7  5e:	bdb0      	pop	{r4, r5, r7, pc}Disassembly of section .text.OS_loop:00000000 <OS_loop>:void OS_loop(void) {   0:	b580      	push	{r7, lr}   2:	af00      	add	r7, sp, #0	os_loop_sp = SP_c;   4:	466a      	mov	r2, sp   6:	f240 0300 	movw	r3, #0			6: R_ARM_THM_MOVW_ABS_NC	os_loop_sp   a:	f2c0 0300 	movt	r3, #0			a: R_ARM_THM_MOVT_ABS	os_loop_sp   e:	601a      	str	r2, [r3, #0]	os_loop_pc = PC_c;  10:	467a      	mov	r2, pc  12:	f240 0300 	movw	r3, #0			12: R_ARM_THM_MOVW_ABS_NC	os_loop_pc  16:	f2c0 0300 	movt	r3, #0			16: R_ARM_THM_MOVT_ABS	os_loop_pc  1a:	601a      	str	r2, [r3, #0]	do {		if (CheckNextTask()) {  1c:	f7ff fffe 	bl	0 <OS_loop>			1c: R_ARM_THM_CALL	CheckNextTask  20:	4603      	mov	r3, r0  22:	2b00      	cmp	r3, #0  24:	d002      	beq.n	2c <OS_loop+0x2c>			RunNextTask();  26:	f7ff fffe 	bl	0 <OS_loop>			26: R_ARM_THM_CALL	RunNextTask		} else {			Interrupt_Enable();		}	} while (1);  2a:	e7f7      	b.n	fffffff2 <RunNextTaskIRQ+0xfffffff2>	os_loop_pc = PC_c;	do {		if (CheckNextTask()) {			RunNextTask();		} else {			Interrupt_Enable();  2c:	f7ff fffe 	bl	0 <OS_loop>			2c: R_ARM_THM_CALL	Interrupt_Enable		}	} while (1);  30:	e7f4      	b.n	1c <OS_loop+0x1c>  32:	bf00      	nopDisassembly of section .text.checkAutoStartSetReady:00000000 <checkAutoStartSetReady>:}void checkAutoStartSetReady(TASK *tasks, int size) {   0:	b5f0      	push	{r4, r5, r6, r7, lr}   2:	b089      	sub	sp, #36	; 0x24   4:	af04      	add	r7, sp, #16   6:	6078      	str	r0, [r7, #4]   8:	6039      	str	r1, [r7, #0]	int i;	for (i = 0; i < size; i++) {   a:	f04f 0300 	mov.w	r3, #0   e:	60fb      	str	r3, [r7, #12]  10:	e041      	b.n	96 <checkAutoStartSetReady+0x96>		if (tasks[i].autostart == 1) {  12:	68fa      	ldr	r2, [r7, #12]  14:	4613      	mov	r3, r2  16:	ea4f 03c3 	mov.w	r3, r3, lsl #3  1a:	1a9b      	subs	r3, r3, r2  1c:	ea4f 0383 	mov.w	r3, r3, lsl #2  20:	687a      	ldr	r2, [r7, #4]  22:	18d3      	adds	r3, r2, r3  24:	785b      	ldrb	r3, [r3, #1]  26:	b2db      	uxtb	r3, r3  28:	2b01      	cmp	r3, #1  2a:	d130      	bne.n	8e <checkAutoStartSetReady+0x8e>			tasks[i].state = READY; //si tiene autostart la tarea se va a ready  2c:	68fa      	ldr	r2, [r7, #12]  2e:	4613      	mov	r3, r2  30:	ea4f 03c3 	mov.w	r3, r3, lsl #3  34:	1a9b      	subs	r3, r3, r2  36:	ea4f 0383 	mov.w	r3, r3, lsl #2  3a:	687a      	ldr	r2, [r7, #4]  3c:	18d3      	adds	r3, r2, r3  3e:	f04f 0201 	mov.w	r2, #1  42:	761a      	strb	r2, [r3, #24]			tasks[i].autostart = 0;  44:	68fa      	ldr	r2, [r7, #12]  46:	4613      	mov	r3, r2  48:	ea4f 03c3 	mov.w	r3, r3, lsl #3  4c:	1a9b      	subs	r3, r3, r2  4e:	ea4f 0383 	mov.w	r3, r3, lsl #2  52:	687a      	ldr	r2, [r7, #4]  54:	18d3      	adds	r3, r2, r3  56:	f04f 0200 	mov.w	r2, #0  5a:	705a      	strb	r2, [r3, #1]			Queue_Add(ready_queue, tasks[i]);  5c:	f240 0300 	movw	r3, #0			5c: R_ARM_THM_MOVW_ABS_NC	ready_queue  60:	f2c0 0300 	movt	r3, #0			60: R_ARM_THM_MOVT_ABS	ready_queue  64:	681e      	ldr	r6, [r3, #0]  66:	68fa      	ldr	r2, [r7, #12]  68:	4613      	mov	r3, r2  6a:	ea4f 03c3 	mov.w	r3, r3, lsl #3  6e:	1a9b      	subs	r3, r3, r2  70:	ea4f 0383 	mov.w	r3, r3, lsl #2  74:	687a      	ldr	r2, [r7, #4]  76:	18d4      	adds	r4, r2, r3  78:	466d      	mov	r5, sp  7a:	f104 030c 	add.w	r3, r4, #12  7e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}  80:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}  84:	e894 000e 	ldmia.w	r4, {r1, r2, r3}  88:	4630      	mov	r0, r6  8a:	f7ff fffe 	bl	0 <Queue_Add>			8a: R_ARM_THM_CALL	Queue_Add	} while (1);}void checkAutoStartSetReady(TASK *tasks, int size) {	int i;	for (i = 0; i < size; i++) {  8e:	68fb      	ldr	r3, [r7, #12]  90:	f103 0301 	add.w	r3, r3, #1  94:	60fb      	str	r3, [r7, #12]  96:	68fa      	ldr	r2, [r7, #12]  98:	683b      	ldr	r3, [r7, #0]  9a:	429a      	cmp	r2, r3  9c:	dbb9      	blt.n	12 <checkAutoStartSetReady+0x12>			tasks[i].state = READY; //si tiene autostart la tarea se va a ready			tasks[i].autostart = 0;			Queue_Add(ready_queue, tasks[i]);		}	}}  9e:	f107 0714 	add.w	r7, r7, #20  a2:	46bd      	mov	sp, r7  a4:	bdf0      	pop	{r4, r5, r6, r7, pc}  a6:	bf00      	nopDisassembly of section .text.Interrupt_Disable:00000000 <Interrupt_Disable>:void Interrupt_Disable(void) {   0:	b480      	push	{r7}   2:	af00      	add	r7, sp, #0	if (interrupts_enabled == 1) {   4:	f240 0300 	movw	r3, #0			4: R_ARM_THM_MOVW_ABS_NC	interrupts_enabled   8:	f2c0 0300 	movt	r3, #0			8: R_ARM_THM_MOVT_ABS	interrupts_enabled   c:	781b      	ldrb	r3, [r3, #0]   e:	2b01      	cmp	r3, #1  10:	d114      	bne.n	3c <Interrupt_Disable+0x3c>		NVIC_ICER(1) |= 0xFFFFFFFF;  12:	f44f 4361 	mov.w	r3, #57600	; 0xe100  16:	f2ce 0300 	movt	r3, #57344	; 0xe000  1a:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84  1e:	f44f 4361 	mov.w	r3, #57600	; 0xe100  22:	f2ce 0300 	movt	r3, #57344	; 0xe000  26:	f04f 32ff 	mov.w	r2, #4294967295  2a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84		interrupts_enabled = 0;  2e:	f240 0300 	movw	r3, #0			2e: R_ARM_THM_MOVW_ABS_NC	interrupts_enabled  32:	f2c0 0300 	movt	r3, #0			32: R_ARM_THM_MOVT_ABS	interrupts_enabled  36:	f04f 0200 	mov.w	r2, #0  3a:	701a      	strb	r2, [r3, #0]	}}  3c:	46bd      	mov	sp, r7  3e:	bc80      	pop	{r7}  40:	4770      	bx	lr  42:	bf00      	nopDisassembly of section .text.Interrupt_Enable:00000000 <Interrupt_Enable>:void Interrupt_Enable(void) {   0:	b480      	push	{r7}   2:	af00      	add	r7, sp, #0	if (interrupts_enabled == 0) {   4:	f240 0300 	movw	r3, #0			4: R_ARM_THM_MOVW_ABS_NC	interrupts_enabled   8:	f2c0 0300 	movt	r3, #0			8: R_ARM_THM_MOVT_ABS	interrupts_enabled   c:	781b      	ldrb	r3, [r3, #0]   e:	2b00      	cmp	r3, #0  10:	d12a      	bne.n	68 <Interrupt_Enable+0x68>		NVIC_ISER(1) |= (1<<(61%32));  12:	f44f 4361 	mov.w	r3, #57600	; 0xe100  16:	f2ce 0300 	movt	r3, #57344	; 0xe000  1a:	f44f 4261 	mov.w	r2, #57600	; 0xe100  1e:	f2ce 0200 	movt	r2, #57344	; 0xe000  22:	6852      	ldr	r2, [r2, #4]  24:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000  28:	605a      	str	r2, [r3, #4]		NVIC_ISER(1) |= (1<<(59%32));  2a:	f44f 4361 	mov.w	r3, #57600	; 0xe100  2e:	f2ce 0300 	movt	r3, #57344	; 0xe000  32:	f44f 4261 	mov.w	r2, #57600	; 0xe100  36:	f2ce 0200 	movt	r2, #57344	; 0xe000  3a:	6852      	ldr	r2, [r2, #4]  3c:	f042 6200 	orr.w	r2, r2, #134217728	; 0x8000000  40:	605a      	str	r2, [r3, #4]		NVIC_ISER(1) |= (1<<(58%32));		//Activate the LPTM interrupt  42:	f44f 4361 	mov.w	r3, #57600	; 0xe100  46:	f2ce 0300 	movt	r3, #57344	; 0xe000  4a:	f44f 4261 	mov.w	r2, #57600	; 0xe100  4e:	f2ce 0200 	movt	r2, #57344	; 0xe000  52:	6852      	ldr	r2, [r2, #4]  54:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000  58:	605a      	str	r2, [r3, #4]		interrupts_enabled = 1;  5a:	f240 0300 	movw	r3, #0			5a: R_ARM_THM_MOVW_ABS_NC	interrupts_enabled  5e:	f2c0 0300 	movt	r3, #0			5e: R_ARM_THM_MOVT_ABS	interrupts_enabled  62:	f04f 0201 	mov.w	r2, #1  66:	701a      	strb	r2, [r3, #0]	}}  68:	46bd      	mov	sp, r7  6a:	bc80      	pop	{r7}  6c:	4770      	bx	lr  6e:	bf00      	nopDisassembly of section .text.get_task_by_id:00000000 <get_task_by_id>:TASK get_task_by_id(int task_id) {   0:	b4b0      	push	{r4, r5, r7}   2:	b083      	sub	sp, #12   4:	af00      	add	r7, sp, #0   6:	6078      	str	r0, [r7, #4]   8:	6039      	str	r1, [r7, #0]	return task_arr[task_id];   a:	6878      	ldr	r0, [r7, #4]   c:	f240 0200 	movw	r2, #0			c: R_ARM_THM_MOVW_ABS_NC	task_arr  10:	f2c0 0200 	movt	r2, #0			10: R_ARM_THM_MOVT_ABS	task_arr  14:	6839      	ldr	r1, [r7, #0]  16:	460b      	mov	r3, r1  18:	ea4f 03c3 	mov.w	r3, r3, lsl #3  1c:	1a5b      	subs	r3, r3, r1  1e:	ea4f 0383 	mov.w	r3, r3, lsl #2  22:	18d3      	adds	r3, r2, r3  24:	4604      	mov	r4, r0  26:	461d      	mov	r5, r3  28:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}  2a:	c40f      	stmia	r4!, {r0, r1, r2, r3}  2c:	e895 0007 	ldmia.w	r5, {r0, r1, r2}  30:	e884 0007 	stmia.w	r4, {r0, r1, r2}}  34:	6878      	ldr	r0, [r7, #4]  36:	f107 070c 	add.w	r7, r7, #12  3a:	46bd      	mov	sp, r7  3c:	bcb0      	pop	{r4, r5, r7}  3e:	4770      	bx	lrDisassembly of section .text.OS_save_context:00000000 <OS_save_context>:void OS_save_context(void) {   0:	b480      	push	{r7}   2:	af00      	add	r7, sp, #0	context_sp = SP_c;   4:	466a      	mov	r2, sp   6:	f240 0300 	movw	r3, #0			6: R_ARM_THM_MOVW_ABS_NC	context_sp   a:	f2c0 0300 	movt	r3, #0			a: R_ARM_THM_MOVT_ABS	context_sp   e:	601a      	str	r2, [r3, #0]	context_sp += 0x04;  10:	f240 0300 	movw	r3, #0			10: R_ARM_THM_MOVW_ABS_NC	context_sp  14:	f2c0 0300 	movt	r3, #0			14: R_ARM_THM_MOVT_ABS	context_sp  18:	681b      	ldr	r3, [r3, #0]  1a:	f103 0204 	add.w	r2, r3, #4  1e:	f240 0300 	movw	r3, #0			1e: R_ARM_THM_MOVW_ABS_NC	context_sp  22:	f2c0 0300 	movt	r3, #0			22: R_ARM_THM_MOVT_ABS	context_sp  26:	601a      	str	r2, [r3, #0]	context_pointer = (uint32_t*) context_sp;  28:	f240 0300 	movw	r3, #0			28: R_ARM_THM_MOVW_ABS_NC	context_sp  2c:	f2c0 0300 	movt	r3, #0			2c: R_ARM_THM_MOVT_ABS	context_sp  30:	681b      	ldr	r3, [r3, #0]  32:	461a      	mov	r2, r3  34:	f240 0300 	movw	r3, #0			34: R_ARM_THM_MOVW_ABS_NC	context_pointer  38:	f2c0 0300 	movt	r3, #0			38: R_ARM_THM_MOVT_ABS	context_pointer  3c:	601a      	str	r2, [r3, #0]}  3e:	46bd      	mov	sp, r7  40:	bc80      	pop	{r7}  42:	4770      	bx	lrDisassembly of section .text.getRunningTaskID:00000000 <getRunningTaskID>:int32_t getRunningTaskID() {   0:	b480      	push	{r7}   2:	af00      	add	r7, sp, #0return runningTask.id;   4:	f240 0300 	movw	r3, #0			4: R_ARM_THM_MOVW_ABS_NC	runningTask   8:	f2c0 0300 	movt	r3, #0			8: R_ARM_THM_MOVT_ABS	runningTask   c:	691b      	ldr	r3, [r3, #16]}   e:	4618      	mov	r0, r3  10:	46bd      	mov	sp, r7  12:	bc80      	pop	{r7}  14:	4770      	bx	lr  16:	bf00      	nopDisassembly of section .text.LPTimer_Init:00000000 <LPTimer_Init>:void LPTimer_Init(void) {   0:	b480      	push	{r7}   2:	af00      	add	r7, sp, #0//LPTimerSIM_SCGC5 |= (1 << 0); //Activate the LPTMR in the system control gating register   4:	f44f 43e0 	mov.w	r3, #28672	; 0x7000   8:	f2c4 0304 	movt	r3, #16388	; 0x4004   c:	f44f 42e0 	mov.w	r2, #28672	; 0x7000  10:	f2c4 0204 	movt	r2, #16388	; 0x4004  14:	f502 5281 	add.w	r2, r2, #4128	; 0x1020  18:	f102 0218 	add.w	r2, r2, #24  1c:	6812      	ldr	r2, [r2, #0]  1e:	f042 0201 	orr.w	r2, r2, #1  22:	f503 5381 	add.w	r3, r3, #4128	; 0x1020  26:	f103 0318 	add.w	r3, r3, #24  2a:	601a      	str	r2, [r3, #0]LPTMR0_PSR = 0b0000101; //Bypass the preescaler and select the LPO(low power oscilator of 1Khz as the source of the timer)  2c:	f04f 0300 	mov.w	r3, #0  30:	f2c4 0304 	movt	r3, #16388	; 0x4004  34:	f04f 0205 	mov.w	r2, #5  38:	605a      	str	r2, [r3, #4]LPTMR0_CMR = 500;			//compare of 1000 clock cycles = 1 secs  3a:	f04f 0300 	mov.w	r3, #0  3e:	f2c4 0304 	movt	r3, #16388	; 0x4004  42:	f44f 72fa 	mov.w	r2, #500	; 0x1f4  46:	609a      	str	r2, [r3, #8]LPTMR0_CSR = 0b01000001; //Activate the timer and enable interrupts	  48:	f04f 0300 	mov.w	r3, #0  4c:	f2c4 0304 	movt	r3, #16388	; 0x4004  50:	f04f 0241 	mov.w	r2, #65	; 0x41  54:	601a      	str	r2, [r3, #0]NVIC_ICPR(1) |= (1<<(58%32));		//Clean flag of LPTM in the interrupt vector  56:	f44f 4361 	mov.w	r3, #57600	; 0xe100  5a:	f2ce 0300 	movt	r3, #57344	; 0xe000  5e:	f44f 4261 	mov.w	r2, #57600	; 0xe100  62:	f2ce 0200 	movt	r2, #57344	; 0xe000  66:	f8d2 2184 	ldr.w	r2, [r2, #388]	; 0x184  6a:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000  6e:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184NVIC_ISER(1) |= (1<<(58%32));		//Activate the LPTM interrupt  72:	f44f 4361 	mov.w	r3, #57600	; 0xe100  76:	f2ce 0300 	movt	r3, #57344	; 0xe000  7a:	f44f 4261 	mov.w	r2, #57600	; 0xe100  7e:	f2ce 0200 	movt	r2, #57344	; 0xe000  82:	6852      	ldr	r2, [r2, #4]  84:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000  88:	605a      	str	r2, [r3, #4]}  8a:	46bd      	mov	sp, r7  8c:	bc80      	pop	{r7}  8e:	4770      	bx	lrDisassembly of section .text.RunNextTaskIRQ:00000000 <RunNextTaskIRQ>:void RunNextTaskIRQ(void) {   0:	b5f0      	push	{r4, r5, r6, r7, lr}   2:	b085      	sub	sp, #20   4:	af04      	add	r7, sp, #16	if (runningTask.label == 'X') {   6:	f240 0300 	movw	r3, #0			6: R_ARM_THM_MOVW_ABS_NC	runningTask   a:	f2c0 0300 	movt	r3, #0			a: R_ARM_THM_MOVT_ABS	runningTask   e:	7b1b      	ldrb	r3, [r3, #12]  10:	b2db      	uxtb	r3, r3  12:	2b58      	cmp	r3, #88	; 0x58  14:	d112      	bne.n	3c <RunNextTaskIRQ+0x3c>		runningTask = nextTask;  16:	f240 0200 	movw	r2, #0			16: R_ARM_THM_MOVW_ABS_NC	runningTask  1a:	f2c0 0200 	movt	r2, #0			1a: R_ARM_THM_MOVT_ABS	runningTask  1e:	f240 0300 	movw	r3, #0			1e: R_ARM_THM_MOVW_ABS_NC	nextTask  22:	f2c0 0300 	movt	r3, #0			22: R_ARM_THM_MOVT_ABS	nextTask  26:	4614      	mov	r4, r2  28:	461d      	mov	r5, r3  2a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}  2c:	c40f      	stmia	r4!, {r0, r1, r2, r3}  2e:	e895 0007 	ldmia.w	r5, {r0, r1, r2}  32:	e884 0007 	stmia.w	r4, {r0, r1, r2}		RunTask();  36:	f7ff fffe 	bl	0 <RunNextTaskIRQ>			36: R_ARM_THM_CALL	RunTask  3a:	e056      	b.n	cc <RunNextTaskIRQ+0xcc>	} else if (nextTask.priority > runningTask.priority) {  3c:	f240 0300 	movw	r3, #0			3c: R_ARM_THM_MOVW_ABS_NC	nextTask  40:	f2c0 0300 	movt	r3, #0			40: R_ARM_THM_MOVT_ABS	nextTask  44:	781b      	ldrb	r3, [r3, #0]  46:	b2da      	uxtb	r2, r3  48:	f240 0300 	movw	r3, #0			48: R_ARM_THM_MOVW_ABS_NC	runningTask  4c:	f2c0 0300 	movt	r3, #0			4c: R_ARM_THM_MOVT_ABS	runningTask  50:	781b      	ldrb	r3, [r3, #0]  52:	b2db      	uxtb	r3, r3  54:	429a      	cmp	r2, r3  56:	d934      	bls.n	c2 <RunNextTaskIRQ+0xc2>		runningTask.state = READY;  58:	f240 0300 	movw	r3, #0			58: R_ARM_THM_MOVW_ABS_NC	runningTask  5c:	f2c0 0300 	movt	r3, #0			5c: R_ARM_THM_MOVT_ABS	runningTask  60:	f04f 0201 	mov.w	r2, #1  64:	761a      	strb	r2, [r3, #24]		runningTask.context_required = 1;  66:	f240 0300 	movw	r3, #0			66: R_ARM_THM_MOVW_ABS_NC	runningTask  6a:	f2c0 0300 	movt	r3, #0			6a: R_ARM_THM_MOVT_ABS	runningTask  6e:	f04f 0201 	mov.w	r2, #1  72:	765a      	strb	r2, [r3, #25]		Queue_Add(ready_queue, runningTask);  74:	f240 0300 	movw	r3, #0			74: R_ARM_THM_MOVW_ABS_NC	ready_queue  78:	f2c0 0300 	movt	r3, #0			78: R_ARM_THM_MOVT_ABS	ready_queue  7c:	681e      	ldr	r6, [r3, #0]  7e:	f240 0400 	movw	r4, #0			7e: R_ARM_THM_MOVW_ABS_NC	runningTask  82:	f2c0 0400 	movt	r4, #0			82: R_ARM_THM_MOVT_ABS	runningTask  86:	466d      	mov	r5, sp  88:	f104 030c 	add.w	r3, r4, #12  8c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}  8e:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}  92:	e894 000e 	ldmia.w	r4, {r1, r2, r3}  96:	4630      	mov	r0, r6  98:	f7ff fffe 	bl	0 <Queue_Add>			98: R_ARM_THM_CALL	Queue_Add		runningTask = nextTask;  9c:	f240 0200 	movw	r2, #0			9c: R_ARM_THM_MOVW_ABS_NC	runningTask  a0:	f2c0 0200 	movt	r2, #0			a0: R_ARM_THM_MOVT_ABS	runningTask  a4:	f240 0300 	movw	r3, #0			a4: R_ARM_THM_MOVW_ABS_NC	nextTask  a8:	f2c0 0300 	movt	r3, #0			a8: R_ARM_THM_MOVT_ABS	nextTask  ac:	4614      	mov	r4, r2  ae:	461d      	mov	r5, r3  b0:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}  b2:	c40f      	stmia	r4!, {r0, r1, r2, r3}  b4:	e895 0007 	ldmia.w	r5, {r0, r1, r2}  b8:	e884 0007 	stmia.w	r4, {r0, r1, r2}		RunTask();  bc:	f7ff fffe 	bl	0 <RunNextTaskIRQ>			bc: R_ARM_THM_CALL	RunTask  c0:	e013      	b.n	2e <RunNextTaskIRQ+0x2e>	} else {		//Case when a task activated another task that has lower priority so the current task continues		Queue_Add(ready_queue, nextTask);  c2:	f240 0300 	movw	r3, #0			c2: R_ARM_THM_MOVW_ABS_NC	ready_queue  c6:	f2c0 0300 	movt	r3, #0			c6: R_ARM_THM_MOVT_ABS	ready_queue  ca:	681e      	ldr	r6, [r3, #0]  cc:	f240 0400 	movw	r4, #0			cc: R_ARM_THM_MOVW_ABS_NC	nextTask  d0:	f2c0 0400 	movt	r4, #0			d0: R_ARM_THM_MOVT_ABS	nextTask  d4:	466d      	mov	r5, sp  d6:	f104 030c 	add.w	r3, r4, #12  da:	cb0f      	ldmia	r3, {r0, r1, r2, r3}  dc:	e885 000f 	stmia.w	r5, {r0, r1, r2, r3}  e0:	e894 000e 	ldmia.w	r4, {r1, r2, r3}  e4:	4630      	mov	r0, r6  e6:	f7ff fffe 	bl	0 <Queue_Add>			e6: R_ARM_THM_CALL	Queue_Add		//runningTask.return_direction = a;	}}  ea:	f107 0704 	add.w	r7, r7, #4  ee:	46bd      	mov	sp, r7  f0:	bdf0      	pop	{r4, r5, r6, r7, pc}  f2:	bf00      	nop